/*jslint node: true, vars: true */

/*

This message is sent from the Reference Source Adapter to the Reference Source Privacy Agent
and contains the subject results.

 Contains utils for validating the apply outbound request privacy pipe request
 from the adapter

 Its V1 message format is

 {
   "@graph": [{
     "@id": "the @id that was passed to the adapter as result of apply inbound",
     "@type": "http://pn.schema.webshield.io/type#RSSubjectQuery"
   }, {
     "@id": "subject specific @id that corrresponds to the sourceID",
     "@type": "https://<specific subject type>/type#Subject",
     "https://pn.schema.webshield.io/prop#job_id": < the @id of the query restriction node that found this subject>
     "https://pn.schema.webshield.io/prop#sourceID":
     <subject specific properties>
   }]
 }

 If cannot find a subject the following subject information is returned

 {
   {   “@id” : "The @id from the subject restiction that was used to find the subject",
       “@type: [“https://pn.schema.webshield.io/type#Error,
         “http://pn.schema.webshield.io/prop#error_code: :404”
   }
 ]
 }


 The V2 message format is

 {
   "id": an id that can be used for tracking locally
   "type": RSAQueryResult,
   "responding_to": the @id of the query that this is the results for
   "version": '2'
   "subjects": [] of subject JSONLD nodes see below
   "links": [] of subject link credential nodes, see below
   "not_matched": [] of subjects that could not be matched
 }

 The subject JSONLD nodes are of the following format
  {
    "@id": "the contents of the sourceID, if not a URL RSPA will convert to URL and append this value",
    "@type": "https://<specific subject type>/type#Subject",
    "https://pn.schema.webshield.io/prop#syndication_job_id": < the @id of the query node that found this subject>
    "https://pn.schema.webshield.io/prop#sourceID": either a value or a globally unique URL
    <subject specific properties>
  }

 The subjects not matched nodes have the following subject information

   {   “@id” : "a globally unique @id that includes the domain name ",
       “@type: [“https://pn.schema.webshield.io/type#Error,
       “http://pn.schema.webshield.io/prop#error_code: :404”,
       "https://pn.schema.webshield.io/prop#syndication_job_id": < the @id of the query restriction node that found this subject>

   }

  The link credential nodes are of the followig format
  { @id: a gloablly unqiue URL or a unique value that can be appended to the URL generated by the RSPA
    @type:
    https://pn.schema.webshield.io/link_subject: the jsonld subject node that has atleast the @id and @type, can be more attributes of need
    http://pn.schema.webshied.io/subject: the jsonld query node that was used to find the subject
    <custom link properties properties>
  }

 */

const assert = require('assert');
const moment = require('moment');
const PNDataModel = require('data-models/lib/PNDataModel');
const PN_T = PNDataModel.TYPE;
const util = require('util');

let messageIdCounter = 0;
function nextIdCounter() {
  'use strict';
  messageIdCounter = messageIdCounter + 1;
  return moment().unix() + '-' + messageIdCounter;
}

class ApplyOutboundPPRequest {

  // props.notMatched - optional
  static createJSON(domainName, query, subjectResults, linkCredentials, props) {
    assert(domainName, 'createJSON domainName param is missing');
    assert(query, 'createJSON query param is missing');
    assert(subjectResults, 'createJSON subjectResults param is missing');
    assert(linkCredentials, 'createJSON linkCredentials param is missing');

    let mess = {
      id: PNDataModel.ids.createQueryResultId(domainName, nextIdCounter()),
      type: 'RSAQueryResult',
      version: '2',
      responding_to: query['@id'],
      subjects: subjectResults,
      links: linkCredentials,
    };

    if ((props) && (props.not_matched)) {
      mess.not_matched = props.notMatched;
    }

    return mess;
  }

  static validateJSON(rq, hostname) {

    if (!rq) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no %s passed in request', PN_T.RSSubjectQuery),
      });
    }

    if (!rq.version) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no version passed in request:%j', rq),
      });
    }

    if (rq.version !== '2') {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR unknown version passed in request:%j', rq),
      });
    }

    if (!rq.responding_to) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no responding_to passed in request:%j', rq),
      });
    }

    if (!rq.subjects) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no subjects passed in request:%j', rq),
      });
    }

    if (!rq.links) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no links passed in request:%j', rq),
      });
    }

    return null;
  }

  /* OLD CODE USED WITH V1, as NO V1 adapters only add back if customer
     cannot upgrade adapter

  // find the query node - not should check if more than one
  static findQueryNode(rq) {

    let results = ApplyOutboundPPRequest.findNodes(rq, PN_T.RSSubjectQuery);
    if (results.length === 0) {
      return null;
    } else {
      return results[0];
    }
  }

  // find the query node - not should check if more than one
  static findNodes(rq, type) {

    let results = [];
    for (let i = 0; i < rq['@graph'].length; i++) {
      if (JSONLDUtils.isType(rq['@graph'][i], type)) {
        results.push(rq['@graph'][i]);
      }
    }

    return results;
  } */
} // class

// just want to expose the class and nothing else and allow
// parties to issue statements such
//
// const ApplyOutboundPPRequest = require('..../ApplyOutboundPPRequest');
// let invalid = ApplyOutboundPPRequest.validateJSON()
// ley ApplyOutboundPPRequest = ApplyOutboundPPRequest(req);
//
module.exports = ApplyOutboundPPRequest;
