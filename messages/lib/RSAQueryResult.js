/*jslint node: true, vars: true */

/*

This message is sent from the Reference Source Adapter to the Reference Source Privacy Agent
and contains the subject results as the body of an apply outbound privacy pipe message

 Contains utils for validating the apply outbound request privacy pipe request
 from the adapter

 Its V1 message format is

 {
   "@graph": [{
     "@id": "the @id that was passed to the adapter as result of apply inbound",
     "@type": "http://pn.schema.webshield.io/type#RSSubjectQuery"
   }, {
     "@id": "subject specific @id that corrresponds to the sourceID",
     "@type": "https://<specific subject type>/type#Subject",
     "https://pn.schema.webshield.io/prop#job_id": < the @id of the query restriction node that found this subject>
     "https://pn.schema.webshield.io/prop#sourceID":
     <subject specific properties>
   }]
 }

 If cannot find a subject the following subject information is returned

 {
   {   “@id” : "The @id from the subject restiction that was used to find the subject",
       “@type: [“https://pn.schema.webshield.io/type#Error,
         “http://pn.schema.webshield.io/prop#error_code: :404”
   }
 ]
 }


 The V2 message format is

 {
   "@id": an id that can be used for tracking locally
   "@type": RSAQueryResult,
   "responding_to": the id of the query that this is the results for
   "version": '2'
   "subjects": [] of subject JSONLD nodes see below
   "links": [] of subject link credential nodes, see below
   "not_matched": [] of subjects that could not be matched
 }

 The subject JSONLD nodes are of the following format
  {
    "@id": "the contents of the sourceID, if not a URL RSPA will convert to URL and append this value",
    "@type": "https://<specific subject type>/type#Subject",
    "https://pn.schema.webshield.io/prop#syndication_job_id": < the @id of the query node that found this subject>
    "https://pn.schema.webshield.io/prop#sourceID": either a value or a globally unique URL
    <subject specific properties>
  }

 The subjects not matched nodes have the following subject information

   {   “@id” : "a globally unique @id that includes the domain name ",
       “@type: [“https://pn.schema.webshield.io/type#Error,
       “http://pn.schema.webshield.io/prop#error_code: :404”,
       "https://pn.schema.webshield.io/prop#syndication_job_id": < the @id of the query restriction node that found this subject>

   }

  The link credential nodes are of the followig format
  { @id: a gloablly unqiue URL or a unique value that can be appended to the URL generated by the RSPA
    @type: PN_T.SubjectLinkCredential
    https://pn.schema.webshield.io/link_subject: the jsonld subject node that has atleast the @id and @type, can be more attributes of need
    http://pn.schema.webshied.io/subject: the @id of the subject that was matched note this is actually the @id of the syndicated entity
    <custom link properties properties>
  }

 */

const assert = require('assert');
const JSONLDUtils = require('jsonld-utils/lib/jldUtils').npUtils;
const moment = require('moment');
const PNDataModel = require('data-models/lib/PNDataModel');
const PN_P = PNDataModel.PROPERTY;
const PN_T = PNDataModel.TYPE;
const TestReferenceSourcePNDataModel = require('data-models/lib/TestReferenceSourcePNDataModel');
const util = require('util');

let messageIdCounter = 0;
function nextIdCounter() {
  'use strict';
  messageIdCounter = messageIdCounter + 1;
  return moment().unix() + '-' + messageIdCounter;
}

class RSAQueryResult {

  // props.notMatched - optional
  static createJSON(domainName, query, subjectResults, linkCredentials, props) {
    assert(domainName, 'createJSON domainName param is missing');
    assert(query, 'createJSON query param is missing');
    assert(query['@id'], util.format('createJSON query.@id param is missing:%j', query));
    assert(subjectResults, 'createJSON subjectResults param is missing');
    assert(linkCredentials, 'createJSON linkCredentials param is missing');

    let mess = {
      '@id': PNDataModel.ids.createQueryResultId(domainName, nextIdCounter()),
      '@type': PN_T.RSAQueryResult,
      version: '2',
      responding_to: query['@id'],
      subjects: subjectResults,
      links: linkCredentials,
    };

    if ((props) && (props.not_matched)) {
      mess.not_matched = props.notMatched;
    }

    return mess;
  }

  static validateJSON(rq, hostname) {

    if (!rq) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no %s passed in request', PN_T.RSSubjectQuery),
      });
    }

    if (!rq['@id']) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no @id passed in request:%j', rq),
      });
    }

    if (!rq['@type']) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no @type passed in request:%j', rq),
      });
    }

    if (rq['@type'] !== PN_T.RSAQueryResult) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR @type not:%s request:%j',  PN_T.RSAQueryResult, rq),
      });
    }

    if (!rq.version) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no version passed in request:%j', rq),
      });
    }

    if (rq.version !== '2') {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR unknown version passed in request:%j', rq),
      });
    }

    if (!rq.responding_to) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no responding_to passed in request:%j', rq),
      });
    }

    if (!rq.subjects) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no subjects passed in request:%j', rq),
      });
    }

    if (!rq.links) {
      return PNDataModel.errors.createTypeError({
        id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
        errMsg: util.format('ERROR no links passed in request:%j', rq),
      });
    }

    // validate format of link credentials, can do has a know format
    // subjects are harder as variable
    let link;
    for (let i = 0; i < rq.links.length; i++) {
      link = rq.links[i];

      if (!link['@id']) {
        return PNDataModel.errors.createTypeError({
          id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
          errMsg: util.format('ERROR link does not have @id passed in request:%j', rq),
        });
      }

      if (!link['@type']) {
        return PNDataModel.errors.createTypeError({
          id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
          errMsg: util.format('ERROR link does not have @type passed in request:%j', rq),
        });
      }

      if (!((JSONLDUtils.isType(link, PN_T.SubjectLinkCredential)))) {
        return PNDataModel.errors.createTypeError({
          id: PNDataModel.ids.createErrorId(hostname, moment().unix()),
          errMsg: util.format('ERROR type is not [%s] missing in:%j', PN_T.SubjectLinkCredential, link),
        });
      }

      if (!link[PN_P.linkSubject]) {
        return PNDataModel.errors.createTypeError({
          id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
          errMsg: util.format('ERROR link does not have %s passed in request:%j', PN_P.linkSubject, rq),
        });
      }

      if (!link[PN_P.linkSubject]['@id']) {
        return PNDataModel.errors.createTypeError({
          id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
          errMsg: util.format('ERROR link subject does not have an @id passed in request:%j', rq),
        });
      }

      if (!link[PN_P.linkSubject]['@type']) {
        return PNDataModel.errors.createTypeError({
          id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
          errMsg: util.format('ERROR link subject does not have an @type passed in request:%j', rq),
        });
      }

      if (!link[PN_P.subject]) {
        return PNDataModel.errors.createTypeError({
          id: PNDataModel.ids.createErrorId(hostname, nextIdCounter()),
          errMsg: util.format('ERROR link does not have %s passed in request:%j', PN_P.subject, rq),
        });
      }

    }

    return null;
  }

  static createCanonJSON(props) {
    assert(props, 'createCanonJSON props param is missing');
    assert(props.id, util.format('createCanonJSON props.id is missing:%j', props));

    // add query
    let query = {
        '@id': props.id,
        '@type': [PN_T.RSAQueryResult],
      };

    // create test subject restrictions
    let subProps = { domainName: 'fake.com', };
    let alice = TestReferenceSourcePNDataModel.canons.createAlice(subProps);
    alice[PN_P.jobID] = 'job-1';

    let bob = TestReferenceSourcePNDataModel.canons.createBob(subProps);
    bob[PN_P.jobID] = 'job-2';

    //
    // create links credentials
    //
    let aliceLink = {
      '@id': 'cred_1', // note the RSPA will convert to a URL
      '@type': PN_T.SubjectLinkCredential,
      [PN_P.linkSubject]: { '@id': alice['@id'], '@type': alice['@type'], }, // the reference source subject
      [PN_P.subject]: 'https://pn.id.webshield.io/syndicated_entity/localhost#test-se-1', // hard coded from RSQuery canon!!!!
    };

    let bobLink = {
      '@id': 'cred_1', // note the RSPA will convert to a URL
      '@type': PN_T.SubjectLinkCredential,
      [PN_P.linkSubject]: { '@id': bob['@id'], '@type': bob['@type'], }, // the reference source subject
      [PN_P.subject]: 'https://pn.id.webshield.io/syndicated_entity/localhost#test-se-2', // hard coded from RSQuery canon!!!!
    };

    return RSAQueryResult.createJSON(
                  'fake.com',
                  query,
                  [alice, bob], // subject results
                  [aliceLink, bobLink] //linkCredentials
                );
  }

} // class

// just want to expose the class and nothing else and allow
// parties to issue statements such
//
// const ApplyOutboundPPRequest = require('..../ApplyOutboundPPRequest');
// let invalid = ApplyOutboundPPRequest.validateJSON()
// ley ApplyOutboundPPRequest = ApplyOutboundPPRequest(req);
//
module.exports = RSAQueryResult;
